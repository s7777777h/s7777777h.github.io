<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>s7777777h&#39;s Blog</title>
  
  
  <link href="http://s7777777h.github.io/atom.xml" rel="self"/>
  
  <link href="http://s7777777h.github.io/"/>
  <updated>2025-04-15T04:31:57.651Z</updated>
  <id>http://s7777777h.github.io/</id>
  
  <author>
    <name>s7777777h</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OO第二单元总结-电梯调度</title>
    <link href="http://s7777777h.github.io/2025/04/12/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93-%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6/"/>
    <id>http://s7777777h.github.io/2025/04/12/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93-%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6/</id>
    <published>2025-04-12T12:29:24.000Z</published>
    <updated>2025-04-15T04:31:57.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目回顾"><a href="#题目回顾" class="headerlink" title="题目回顾"></a>题目回顾</h1><h2 id="第一次题目"><a href="#第一次题目" class="headerlink" title="第一次题目"></a>第一次题目</h2><p>有 6 部电梯，在某些时间节点，会有一些乘客发出请求：乘坐指定电梯 e，从楼层 x 到楼层 y，且每个乘客有一个优先级 p。当<strong>电梯开门，关门，到达任一楼层，乘客进出电梯</strong>时，需要输出特定的信息。每一部电梯的移动速度给定，同时电梯的开关门之间有一定的时间间隔。目标是将所有乘客送到目的地（正确性），且使得系统总运行时间，乘客优先级加权等待时间，电梯耗电量（与开关门次数和移动次数有关）最小化。</p><h2 id="第二次迭代"><a href="#第二次迭代" class="headerlink" title="第二次迭代"></a>第二次迭代</h2><p>乘客<strong>不再指定</strong>乘坐哪一部电梯，而是由系统自行决定。同时，新增临时调度(SCHE) 事件，要求指定电梯以特定移动速度，从楼层 x 移动到楼层 y ，到达 y 后使所有乘客离开，关门并等待一秒，结束临时调度事件。SCHE-BEGIN 必须在输入 SCHE 后短时间内输出（不能有两次 ARRIVE）。临时调度期间不能有 RECEIVE和中间楼层的开关门。 </p><p>同时，新增了 RECEIVE 约束，当将乘客分给某个电梯时，要输出一条分配信息，当电梯没有任何的 RECEIVE 时，电梯不能移动（防止自由竞争策略）。</p><p>RECEIVE 的解除有两种情况：当乘客离开电梯时会解除其的 RECEIVE ；电梯进入 SCHE 事件时会将所有已经 RECEIVE 的人全部解除。当RECEIVE解除后，乘客必须重新分配电梯，同时电梯如果没有RECEIVE任何人，电梯不能移动。</p><h2 id="第三次迭代"><a href="#第三次迭代" class="headerlink" title="第三次迭代"></a>第三次迭代</h2><p>第三次迭代增加了双轿厢升级事件（UPDATE），其指定两个电梯和一个楼层。发出请求后，两个电梯会停止，放出内部的所有人，取消所有人的 RECEIVE ，接下来两个电梯停止一秒后分别传送到共享楼层的上下楼层位置。接下来两个电梯的速度加倍，且两个电梯的楼层移动范围加以限制，均无法越过共享楼层。同时两个电梯加以限制不能相撞。</p><h1 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h1><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><p><img src="/2025/04/12/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93-%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6/%E7%B1%BB%E5%9B%BE.png"></p><h2 id="Sequence-Diagram"><a href="#Sequence-Diagram" class="headerlink" title="Sequence Diagram"></a>Sequence Diagram</h2><p><img src="/2025/04/12/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93-%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6/%E6%AE%B5%E5%9B%BE.png"></p><blockquote><p>注，此处的 Elevator 泛指六个电梯线程，而 ElevatorA，ElevatorB 主要用来展示 UPDATE 时的线程工作状况。</p></blockquote><h2 id="度量分析"><a href="#度量分析" class="headerlink" title="度量分析"></a>度量分析</h2><p><img src="/2025/04/12/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93-%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6/%E5%BA%A6%E9%87%8F.png"> </p><p><img src="/2025/04/12/OO%E7%AC%AC%E4%BA%8C%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93-%E7%94%B5%E6%A2%AF%E8%B0%83%E5%BA%A6/%E5%BA%A6%E9%87%8F1.png"></p><h1 id="实现方案介绍"><a href="#实现方案介绍" class="headerlink" title="实现方案介绍"></a>实现方案介绍</h1><h2 id="线程-类介绍"><a href="#线程-类介绍" class="headerlink" title="线程&amp;类介绍"></a>线程&amp;类介绍</h2><p>线程分为三部分：输入线程（Main），分配器线程（Distributor），电梯线程（Elevator）。</p><p>采用典型的<strong>生产者-消费者模式</strong>，为托盘建立 waitingList 类，用于存储管理三种类型的 Request。</p><p>每个电梯同时自身含有两个waitingList，一个存储已分配，但尚未进入轿厢的乘客，一个存储轿厢内的乘客。</p><p>输入线程将请求放在托盘里，分配器线程将托盘里的请求根据一定的规则分配到不同的电梯中。</p><p>Tool 类负责一些静态的杂碎工具方法，如将字符串的楼层映射到数字的楼层，以及反转电梯的运行方向等。</p><p>Debug 类只有一个静态方法，返回一个布尔真值，当这个真值为1，程序输出日志，方便调试。</p><p>用于官方包的 PersonRequest 类没有存储当前楼层的成员，故增加 MyRequest 类，用于存储当前楼层。</p><h2 id="分配实现"><a href="#分配实现" class="headerlink" title="分配实现"></a>分配实现</h2><p>由于每个电梯在SCHE和UPDATE事件中为不可分配状态，故需给每一个电梯设立有效位 <code>valid</code>，在分配时，会检查是否所有电梯都无效，如果是就进入 wait 。在电梯的 <code>valid</code> 被置为 1 时，会叫醒分配器，以保证分配可行。</p><p>对于 UPDATE 和 SCHE （以及第一次作业的乘客请求），目标电梯已经指定，所以直接从取出电梯的候乘表，加入并 notify 即可。</p><p>对于需要我们分配的请求，我专门创建了 <code>int xxx_distribute(MyRequest request)</code> 方法。对于一个请求，返回分配给的电梯序号。以封装的方式，<strong>方便切换分配策略</strong>，来比较各种分配策略的优略。</p><p>经过综合考虑，本人的分配策略最终采用了<strong>基于路程的分配策略</strong>，即直接假定电梯做大简谐运动（触顶返回），计算不同电梯距离请求所在楼层的距离，选取距离最小的。</p><blockquote><p>此方法实现简单，且性能相对不劣，但是核心问题在于<strong>容易被卡</strong>，攻击者可以轻易构造一组数据让你的一部电梯RECEIVE所有人。同时该方法相同数据，每次测试的误差较大（我就因为这个性能 RTLE 了一次）</p></blockquote><p><strong>注意：<strong>电梯是否有效需要多次检查，第一次是检查是否有有效电梯，如果没有就 wait ，第二次是分配策略分配只考虑有效电梯，第三次是</strong>分配行为前一条语句要再次检查</strong>。第三条尤为重要，且<strong>务必要将检查和分配套在一个 synchronized 块中，为电梯的 valid 上锁</strong>，否则经常会出现以下的情况：电梯在通过有效性检查进入 if 分支，在正准备分配前一瞬间被设为无效，再分配便会出问题，这是典型的 check-act 竞态条件。</p><h2 id="调度实现"><a href="#调度实现" class="headerlink" title="调度实现"></a>调度实现</h2><h3 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h3><p>电梯调度策略整体采用LOOK策略，在细节上做了一点点改动。</p><p>LOOK策略的详细机制我直接搬用 Gemini 2.5 Pro 的介绍。如有需要可以自行参考。</p><blockquote><p>我们可以将 LOOK 策略的运行过程分解为以下步骤：</p><ol><li><strong>确定初始方向：</strong><ul><li>如果电梯当前是空闲的，它会等待第一个请求（来自轿厢内部或楼层按钮），并根据该请求的位置确定初始运行方向。</li><li>如果电梯已经在运行中，它会保持当前方向。</li></ul></li><li><strong>沿当前方向移动：</strong><ul><li>电梯开始沿着确定的方向移动（例如，向上）。</li></ul></li><li><strong>服务同向请求：</strong><ul><li>在移动过程中，电梯会停靠并服务所有满足以下条件的楼层：<ul><li>该楼层有 <strong>轿厢内指令</strong> (乘客在电梯内按下的目标楼层按钮)。</li><li>该楼层有 <strong>与电梯当前运行方向一致的层站呼叫</strong> (例如，电梯向上时，停靠发出向上请求的楼层)。</li></ul></li><li>同时，电梯会记录下所有 <strong>反方向</strong> 的请求，以便在改变方向后处理。</li></ul></li><li><strong>查找并到达转向点 (关键步骤)：</strong><ul><li>电梯持续沿当前方向移动，并不断 “向前看” (Look)。</li><li>它会找到当前方向上 <strong>最远的一个请求</strong> (无论是轿厢内指令还是同向的层站呼叫)。</li><li>当电梯到达这个 <strong>最远请求所在的楼层</strong> 并完成服务后，它会再次检查：在这个楼层之外、更远的地方（沿当前方向）是否还有请求？</li><li><strong>如果没有更远的请求了</strong>，那么这个楼层就是本次单向行程的 <strong>转向点</strong>。电梯就在这里停止继续前进（即使还没到顶层&#x2F;底层）。</li></ul></li><li><strong>改变方向：</strong><ul><li>在转向点，电梯改变其运行方向（例如，从向上变为向下）。</li></ul></li><li><strong>沿新方向移动并服务：</strong><ul><li>电梯开始沿新的方向移动。</li><li>重复步骤 3 和 4：服务新方向上的所有同向请求，并找到新方向上的最远请求点作为下一个转向点。</li></ul></li><li><strong>循环往复：</strong><ul><li>电梯就像一个来回摆动的指针，在上下两个 “最远请求点” 之间来回运行，持续服务所有请求。</li><li>如果没有收到任何请求，电梯会进入空闲状态，等待新的请求。</li></ul></li></ol></blockquote><p>我将策略和电梯进行分离，单独建立 Strategy 类，每个电梯都有一个实例化的 Strategy 对象，通过  getAdvice 方法，基于电梯的状态和请求列表，给出电梯相应的指令。分为：<strong>移动，反转移动，开门，关门，等待，临时调度，轿厢升级</strong>七种建议。电梯通过调用相应的功能函数以完成其功能。</p><h3 id="调度的优化"><a href="#调度的优化" class="headerlink" title="调度的优化"></a>调度的优化</h3><p>加权乘客等待时间时课程作业性能评价的一个重要指标。在<strong>最小幅度更改原策略</strong>的原则上，我做了些许改动来适配优先级。</p><p>具体来说，当一个电梯到达任何一个楼层，从 Strategy 得到 OPEN 的指令时，我会将<strong>所有人移出电梯，从电梯外的所有人中选取六个优先级最高的，和电梯运行相同的乘客进入电梯</strong> <del>（我觉得我要被乘客骂死了）</del>。这样能保证对于 LOOK 策略的改动十分小，且不会对电量和总运行时长有较大的影响（理论上会有浮动，但是浮动的期望应当是 0），同时能够尽量满足高优先级的需求。</p><h2 id="双轿厢电梯的实现"><a href="#双轿厢电梯的实现" class="headerlink" title="双轿厢电梯的实现"></a>双轿厢电梯的实现</h2><p> SCHE 的实现与双轿厢电梯较为类似，但更为简单，这里不在赘述。</p><h3 id="双轿厢电梯的启动"><a href="#双轿厢电梯的启动" class="headerlink" title="双轿厢电梯的启动"></a>双轿厢电梯的启动</h3><p>双轿厢的启动其实较为复杂，因为需要保证两个电梯都停下，所有人都出来，且电梯关上了门才可以启动电梯。其核心在于<strong>启动的同步</strong>。这里我设置了主从电梯的概念，用于电梯的启动。由主电梯（选哪个都行）负责输出启动信息。</p><p>具体来说，每一个电梯自身有一个updateReady的标志，但是主从电梯的 updateReady 含义不一样。</p><p><strong>从电梯</strong>：表示已经完成了清空乘客等前置要求，<strong>随时可以升级</strong>。</p><p><strong>主电梯</strong>：表示已经输出了 UPDATE-BEGIN ，已经进入了升级状态，标志着<strong>升级事件的开始</strong>。</p><p>在启动时，从电梯在执行前置操作后，将 updateReady 设置为真，等待主电梯 updateReady，在得到主电梯的 updateReady后，执行真正的升级操作，即取消所有等待乘客的 RECEIVE ，设置速度，顶楼和底层，进行一秒的 sleep。</p><p>主电梯在执行完前置操作后，等待从电梯的 updateReady 为真，再输出 updateReady 为真，接下来的操作和从电梯一样，只是在末尾输出 UPDATE-END。</p><p>电梯的结束同样需要进行上面的同步控制，逻辑几乎相同，这里不再赘述。</p><blockquote><p>PS：结束的同步控制其实我的代码没有做，写博客时才发现有这么个Bug qaq，幸好强测和互测都没出事。</p></blockquote><h3 id="双轿厢电梯的调度"><a href="#双轿厢电梯的调度" class="headerlink" title="双轿厢电梯的调度"></a>双轿厢电梯的调度</h3><p>在双轿厢电梯的迭代中，电梯需要增加顶层和底层两个变量，在分配时，只有 <strong>当前楼层在顶层和底层之间</strong> 才会进行分配。</p><p>如果目标楼层在当前电梯的运行范围内，和往常一样调度即可。</p><p>如果目标楼层不在运行范围内，则将乘客运到共享楼层后。将乘客放回托盘，接下来由调度器分配即可。</p><h3 id="双轿厢电梯的防撞"><a href="#双轿厢电梯的防撞" class="headerlink" title="双轿厢电梯的防撞"></a>双轿厢电梯的防撞</h3><p>电梯的防撞通过给共享楼层加锁实现，为了让锁更加灵活，这里我使用了唯一一处 RetreentLock ,两个电梯共享一把 sharedFloorLock，当电梯无论通过何种方式进入共享楼层之前，都会上锁；电梯无论通过何种方法离开共享楼层，都会解锁。</p><p>为了防止电梯来在共享楼层不走导致另外一个电梯被长期阻塞，我设置了如果电梯内部和外部都没有任务，且在共享楼层，getAdvice 给的建议是 MOVE&#x2F;REVERSE，而不是 WAIT。显然这种情景以外，电梯都会离开。只要给这种情景加特判即可。</p><h2 id="程序的结束"><a href="#程序的结束" class="headerlink" title="程序的结束"></a>程序的结束</h2><p>多线程程序的优雅结束需要线程之间的协作交流，这里展示一下我的结束方式。</p><p>InputThread：下一个输入为空时自然结束</p><p>Distributor：结束需要满足两个条件</p><p>(1) 输入线程结束</p><p>(2) <strong>输入的所有请求被全部完成</strong> - 设立全局共享变量</p><p>Elevator：分配器结束后获得结束许可，在有结束许可，且候乘表和内部为空时结束</p><h2 id="迭代变化总结"><a href="#迭代变化总结" class="headerlink" title="迭代变化总结"></a>迭代变化总结</h2><p>三次作业迭代中<strong>不需要变化</strong>的点：</p><ul><li><p>Elevator 的 move, getOut（使所有乘客出去） 和 getIn（使可以进来的乘客进来） 方法等控制电梯行为逻辑的方法完全不需要变</p></li><li><p>输入线程的主要逻辑不需要变</p></li></ul><p>三次迭代中需要<strong>显著变化</strong>的点</p><ul><li>电梯需要新增 updateEvent 函数和 scheEvent 函数。</li><li>分配器需要增加 xxx_distribute 方法。</li><li>需要对三种 request 进行各自的分配。</li><li>Strategy 中的 getAdvice 需增加两条新的建议，且在升级为双轿厢电梯后要改变开门出客逻辑：即如果乘客的目标不在当前运行楼层，且当前移动到了共享楼层，允许出客。</li></ul><h1 id="多线程安全相关"><a href="#多线程安全相关" class="headerlink" title="多线程安全相关"></a>多线程安全相关</h1><p>第二单元的多线程作业，线程安全相当重要。</p><p>我在自己的代码中几乎全文都用的 synchroinzed 块，只有对共享楼层的加锁使用了 RetreeantLock。我强烈建议大家<strong>不要学习这一行为</strong>，建议大家从最初就使用 RetreeantLock 。它最大的优点是可以自由调整粒度，我可以在一个类的方法中上锁，在另一个类的方法解锁（当然一定要保证上锁后一定会解锁）。这是 synchronized 块做不到的。我的共享楼层加锁就是由于这个原因不得不使用 RetreeantLock，将锁混用实际上时很危险的。</p><p>在加锁时，我遵守的原则是，共享变量读写全加锁，不出现嵌套锁（然而还是有一些隐蔽的导致我Debug非常之久），事实上能满足这些，基本上就不会出现死锁问题和数据冲突问题。</p><p>写方法时，个人不是很建议直接给方法本身加锁，而是给具体某个读写语句和if块加锁，这样精准加锁可以大大提升性能。这样写出来的方法时安全的，就没有必要在调用它时再加锁，防止死锁。</p><h2 id="线程相关经验"><a href="#线程相关经验" class="headerlink" title="线程相关经验"></a>线程相关经验</h2><ul><li>永远永远<strong>不要带锁 sleep</strong> ，sleep 不会释放锁，其他线程会被阻塞的很惨</li><li>锁的范围一定<strong>不要太大</strong>，否则很容易引发死锁和潜在的性能问题</li><li>对于共享变量的读写一定要加锁</li><li>一定要慎重 check - act 的问题，即**<code>if（A） then B</code>** ，如果 A 条件中涉及到一些共享变量，一定要对其加锁</li><li>如无必要，<strong>不要写嵌套锁，不要写嵌套锁，不要写嵌套锁</strong>，尤其注意隐式的嵌套锁（如函数内部有锁，调用的环境也有锁）。写嵌套锁一定要慎重考虑所有情况，保证不会死锁。</li></ul><h1 id="多线程-Debug-相关"><a href="#多线程-Debug-相关" class="headerlink" title="多线程 Debug 相关"></a>多线程 Debug 相关</h1><p>我在这一单元中本地测试出现的 bug 主要是隐藏的嵌套锁导致的死锁。通过<strong>统一使用线程安全的方法，不在方法外套锁可以很好的解决</strong>。</p><p>在 hw6 的强测中，我爆了我 OO 生涯中第一个强测点（希望是最后一个qaq），细究其原因竟是电梯策略较慢导致 RTLE （本地测了4000遍相同的数据发现不是死锁）。我的策略会有些时间上的波动，好多样例都 56s &#x2F; 60s ，偶然出现了一个特别非的卡到了 60s 以上。我还想着保正确性不卷性能，结果性能倒扣我正确性 qaq。</p><p>本单元中我自己总结出了一套丰富的 debug 方法论，如有兴趣可以移步文章 <a href="https://s7777777h.github.io/2025/04/06/%E5%A4%9A%E7%BA%BF%E7%A8%8BDebug%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/">多线程Debug经验分享 | s7777777h’s Blog</a>。</p><h1 id="Unit2-心得体会"><a href="#Unit2-心得体会" class="headerlink" title="Unit2 心得体会"></a>Unit2 心得体会</h1><h2 id="关于层次化设计"><a href="#关于层次化设计" class="headerlink" title="关于层次化设计"></a>关于层次化设计</h2><p>层次化的设计会让整个迭代变得很舒服。通过设计分工明确的方法，可以精确找到每一次迭代自己要做什么，也能让自己少出 bug。</p><p>Unit1 的作业已经能够让我对层次化设计有了成熟的认识，这让我在第二单元的迭代更加如鱼得水，每次的迭代都十分舒适。</p><h2 id="关于线程安全"><a href="#关于线程安全" class="headerlink" title="关于线程安全"></a>关于线程安全</h2><p>线程安全初识感觉非常可怕，十分容易出错，但是在实际编写时，只要心里明白，哪些变量是共享的，然后在读写时注意对其加锁就好。</p><p>每一个函数都设计好，使其线程安全，上层函数就能更好拿它们组装出一个线程安全的上层结构，进而形成线程安全的整体。</p><p>从小处做起，每一步都很重要。</p><blockquote><p>碎碎念</p><p>OOUnit3Unit4强测互测全过OOUnit3Unit4强测互测全过OOUnit3Unit4强测互测全过OOUnit3Unit4强测互测全过OOUnit3Unit4强测互测全过OOUnit3Unit4强测互测全过OOUnit3Unit4强测互测全过OOUnit3Unit4强测互测全过OOUnit3Unit4强测互测全过OOUnit3Unit4强测互测全过OOUnit3Unit4强测互测全过OOUnit3Unit4强测互测全过OOUnit3Unit4强测互测全过OOUnit3Unit4强测互测全过OOUnit3Unit4强测互测全过OOUnit3Unit4强测互测全过OOUnit3Unit4强测互测全过OOUnit3Unit4强测互测全过OOUnit3Unit4强测互测全过</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;题目回顾&quot;&gt;&lt;a href=&quot;#题目回顾&quot; class=&quot;headerlink&quot; title=&quot;题目回顾&quot;&gt;&lt;/a&gt;题目回顾&lt;/h1&gt;&lt;h2 id=&quot;第一次题目&quot;&gt;&lt;a href=&quot;#第一次题目&quot; class=&quot;headerlink&quot; title=&quot;第一次题目&quot;&gt;</summary>
      
    
    
    
    
    <category term="面向对象设计与构造" scheme="http://s7777777h.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>多线程Debug经验分享</title>
    <link href="http://s7777777h.github.io/2025/04/06/%E5%A4%9A%E7%BA%BF%E7%A8%8BDebug%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/"/>
    <id>http://s7777777h.github.io/2025/04/06/%E5%A4%9A%E7%BA%BF%E7%A8%8BDebug%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/</id>
    <published>2025-04-06T08:49:05.000Z</published>
    <updated>2025-04-15T04:32:13.695Z</updated>
    
    <content type="html"><![CDATA[<h1 id="OO多线程-debug-经验分享"><a href="#OO多线程-debug-经验分享" class="headerlink" title="OO多线程 debug 经验分享"></a>OO多线程 debug 经验分享</h1><h3 id="前情提要"><a href="#前情提要" class="headerlink" title="前情提要"></a>前情提要</h3><p>本人4月4日晚上 debug 写到了4月5日凌晨三点，睡前以为修好了bug，在自己评测机上跑了6000组数据，结果第二天起床发现6000组数据中跑出了3个bug，又改到4月5日晚上六点终于改好了（至少跑了3200组数据不成问题）。 这里分享一下这几天 debug 出的心得。</p><h2 id="多线程debug-基础版"><a href="#多线程debug-基础版" class="headerlink" title="多线程debug - 基础版"></a>多线程debug - 基础版</h2><p>IntelliJ IDEA 中有一个强力的多线程分析工具 - 转储线程，这个功能可以在<strong>运行</strong>程序卡死时，查看每个线程的具体情况。我们以最经典的死锁为例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DeadClass</span> <span class="variable">C</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadClass</span>(A, B);</span><br><span class="line">        <span class="type">DeadClass</span> <span class="variable">D</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DeadClass</span>(B, A);</span><br><span class="line">        C.start();</span><br><span class="line">        D.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeadClass</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Object A;</span><br><span class="line">    Object B;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DeadClass</span><span class="params">(Object A, Object B)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.A = A;</span><br><span class="line">        <span class="built_in">this</span>.B = B;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                sleep(<span class="number">10</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread is dead&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>很显然，我们运行main时，会因为死锁导致什么都不输出，我们使用这个转储线程工具，可以看到每个线程走到了哪一步。</p><p><img src="/2025/04/06/%E5%A4%9A%E7%BA%BF%E7%A8%8BDebug%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/thread1.png"></p><p>打开我们的转储线程工具，我们可以看到以下界面。</p><p><img src="/2025/04/06/%E5%A4%9A%E7%BA%BF%E7%A8%8BDebug%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/thread2.png"></p><p>左边有很多项，我们要关心的是其中的Thread-x，这里是我们的线程。点击线程，我们可以看到右边的信息。</p><p>这里显示了我们的0号线程，在持有锁&lt;0x00000007327596b0&gt;的时候，试图获得锁&lt;0x00000007327596a0&gt;，此时正在等待锁被阻塞在16行之前。如果看一号线程可以发现显示的信息几乎一致，只是持有和等待的锁刚好对调过来。我们点击报错中的链接就可以看到具体卡在了哪里。</p><p><img src="/2025/04/06/%E5%A4%9A%E7%BA%BF%E7%A8%8BDebug%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/deadlock.png"></p><p>这里和我们的期望是完全一致的，我们可以通过分析日志来看到死锁发生在了哪里。</p><p>同样，如果线程无法正确结束的问题发生，我们也有可能在这里看到所有的线程都陷入了WAIT状态，可以通过右边的日志来看到具体行数，我们这里不过多赘述了。</p><h2 id="多线程debug-进阶版"><a href="#多线程debug-进阶版" class="headerlink" title="多线程debug - 进阶版"></a>多线程debug - 进阶版</h2><p>这个部分在假定你<strong>有了一台能够自动化生成数据的数据生成器和评测机</strong>的前提下进行，这一部分可以帮助你改装你的评测机，以方便 debug 。</p><p>先提供一下我的初版评测机的整体工作流程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">选择是否调用数据生成器 y / n</span><br><span class="line">如果是</span><br><span class="line">清空 data 文件夹</span><br><span class="line">调用数据生成器，询问需要多少组数据</span><br><span class="line">生成相应的数据</span><br><span class="line">如果否</span><br><span class="line">NOP</span><br><span class="line">给本目录下的所有 JAR 做一个索引</span><br><span class="line">给 data 文件夹下的所有 txt 做一个索引</span><br><span class="line">for JAR in JARS</span><br><span class="line">依次以 data 中的文件作为 stdin ，并行运行程序（我设置了20条线程）</span><br><span class="line">将 stdout 写入 out 文件夹中名为 JARNAME_TESTCASENAME.out的文件中</span><br><span class="line">对于 stdout 进行正确性评价，并记录结果和性能</span><br><span class="line">将结果写入 report 文件夹的 JARNAME.report 中</span><br><span class="line">根据所有的JAR的性能记录，绘制三张性能图表</span><br></pre></td></tr></table></figure><p>评测机还有一些细节，比较重要的是对于每一个数据点设一个时间上限，这里不过多赘述。</p><p>这样的一版评测机非常非常好用，它能十分高效的进行评测（一小时1200组数据），同时能够将结果准确的记录下来。</p><p>然而，本单元debug最重要，也是最困难的一个问题是：**我即使拿到了一组输入数据和我的错误的输出，我也无法复现这个错误。**我们的输出往往不足以支持我们定位到错误原因。</p><p>PS：昨晚我拿着一个我的错误数据跑了三四十次，试图通过转储线程分析原因，但是没能让我的程序再错一次。</p><p>解决方法很简单，但是从零想出这个方法并不是一个很简单的事。</p><h3 id="日志的优雅引入"><a href="#日志的优雅引入" class="headerlink" title="日志的优雅引入"></a>日志的优雅引入</h3><p>我最终通过引入日志这一概念来解决我的整个debug问题，具体来说，我们要建立一个很简单的类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Debug</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">d</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在我们程序运行的关键点，我们可以增加一些关键的输出信息，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Distributor</span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">getEnd</span><span class="params">()</span> &#123;</span><br><span class="line">        ........ </span><br><span class="line">        <span class="keyword">if</span> (Debug.d()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[LOG]Distributor end&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Elevator</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        .....</span><br><span class="line">        advice = strategy.getAdvice(<span class="comment">/*secret!*/</span>);</span><br><span class="line">        <span class="keyword">if</span> (Debug.d()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[LOG] Elevator &quot;</span> +</span><br><span class="line">            <span class="built_in">this</span>.elevatorId + <span class="string">&quot; get advice : &quot;</span> + advice.toString());<span class="comment">//checkstyle所限必须写成两行www</span></span><br><span class="line">        &#125;</span><br><span class="line">        .....</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志的输出有两个要点：</p><ul><li>一定要增加一个静态的统一开关，例如我的 <code>Debug.d()</code>，我在提交时可以直接把 <code>Debug</code> 中的 return 值改为 <code>false</code>，不容易遗漏任何东西。</li><li>一定要统一日志的输出格式，在前面加上一个统一的前缀。</li></ul><p>在第二点的基础上，我们可以改良我们的评测机：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">选择是否调用数据生成器 y / n</span><br><span class="line">如果是</span><br><span class="line">清空 data 文件夹</span><br><span class="line">调用数据生成器，询问需要多少组数据</span><br><span class="line">生成相应的数据</span><br><span class="line">如果否</span><br><span class="line">NOP</span><br><span class="line">给本目录下的所有 JAR 做一个索引</span><br><span class="line">给 data 文件夹下的所有 txt 做一个索引</span><br><span class="line">for JAR in JARS</span><br><span class="line">依次以 data 中的文件作为 stdin ，并行运行程序（我设置了20条线程）</span><br><span class="line">将 stdout 的所有写入 log 文件夹中名为 JARNAME_TESTCASENAME.log的文件中</span><br><span class="line">从 log 中筛选所有没有 [LOG] 前缀的行，记录在 out 文件夹中名为 JARNAME_TESTCASENAME.out的文件中</span><br><span class="line">对于 out 中的结果进行正确性评价，并记录结果和性能</span><br><span class="line">将结果写入 report 文件夹的 JARNAME.report 中</span><br><span class="line">根据所有的JAR的性能记录，绘制三张性能图表</span><br></pre></td></tr></table></figure><p>这样我们就能方便的阅读我们的 log，从中获得我们想要的信息，以方便 debug 。</p><p>以我为例，我展示一下我的 log 的一部分</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">[LOG] Elevator 2 get advice : OPEN</span><br><span class="line">[  60.5440]ARRIVE-B3-4</span><br><span class="line">[LOG] Elevator 4 get advice : OPEN</span><br><span class="line">[  60.5440]OPEN-B3-2</span><br><span class="line">[  60.5440]OPEN-B3-4</span><br><span class="line">[  60.5440]OUT-S-438-B3-4</span><br><span class="line">[  60.5440]OUT-S-168-B3-2</span><br><span class="line">[  60.9150]CLOSE-F4-1</span><br><span class="line">[LOG] Elevator 1 get advice : WAIT</span><br><span class="line">[  60.9460]CLOSE-B3-4</span><br><span class="line">[LOG] Elevator 4 get advice : WAIT</span><br><span class="line">[LOG] Elevator: 4 is waiting</span><br><span class="line">[LOG] Elevator: 5 is waiting</span><br><span class="line">[LOG] Elevator: 3 is waiting</span><br><span class="line">[LOG] Elevator: 6 is waiting</span><br><span class="line">[LOG] Elevator: 4 is waiting</span><br><span class="line">[LOG] Elevator: 5 is waiting</span><br><span class="line">[LOG] Elevator: 3 is waiting</span><br><span class="line">[LOG] Elevator: 6 is waiting</span><br><span class="line">[LOG] Elevator: 4 is waiting</span><br><span class="line">[LOG] Elevator: 5 is waiting</span><br><span class="line">[LOG] Elevator: 3 is waiting</span><br><span class="line">[LOG] Elevator: 6 is waiting</span><br><span class="line">[LOG] Elevator: 4 is waiting</span><br><span class="line">[LOG] Elevator: 5 is waiting</span><br><span class="line">[LOG] Elevator: 3 is waiting</span><br><span class="line">[LOG] Elevator: 6 is waiting</span><br><span class="line">[LOG] Elevator: 4 is waiting</span><br><span class="line">[LOG] Elevator: 5 is waiting</span><br><span class="line">[LOG] Elevator: 3 is waiting</span><br><span class="line">[LOG] Elevator: 6 is waiting</span><br><span class="line">[LOG] Elevator: 4 is waiting</span><br><span class="line">[LOG] Elevator: 5 is waiting</span><br><span class="line">[LOG] Elevator: 3 is waiting</span><br><span class="line">[LOG] Elevator: 6 is waiting</span><br><span class="line">[LOG] Elevator: 4 is waiting</span><br><span class="line">[LOG] Elevator: 5 is waiting</span><br><span class="line">[LOG] Elevator: 3 is</span><br><span class="line">--- STDERR ---</span><br><span class="line">Checker: Soft timeout (220.0s) reached.</span><br><span class="line">Checker: Hard timeout (250.0s) reached. Process killed.</span><br></pre></td></tr></table></figure><p>我通过阅读我的 log，发现电梯2开门后没有关门，电梯1获得等待指令后没有进入等待状态。通过这个线索，我精准定位到了这两个行为后面发生了死锁，修改相关逻辑成功解决了问题。</p><p>日志里面怎么写，也是一门艺术，这里就希望大家自行探索了。</p><h3 id="文末彩蛋："><a href="#文末彩蛋：" class="headerlink" title="文末彩蛋："></a>文末彩蛋：</h3><p><img src="/2025/04/06/%E5%A4%9A%E7%BA%BF%E7%A8%8BDebug%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/ester.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;OO多线程-debug-经验分享&quot;&gt;&lt;a href=&quot;#OO多线程-debug-经验分享&quot; class=&quot;headerlink&quot; title=&quot;OO多线程 debug 经验分享&quot;&gt;&lt;/a&gt;OO多线程 debug 经验分享&lt;/h1&gt;&lt;h3 id=&quot;前情提要&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="面向对象设计与构造" scheme="http://s7777777h.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>OO第一单元总结 - 表达式展开</title>
    <link href="http://s7777777h.github.io/2025/04/06/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B1%95%E5%BC%80/"/>
    <id>http://s7777777h.github.io/2025/04/06/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B1%95%E5%BC%80/</id>
    <published>2025-04-06T08:33:24.000Z</published>
    <updated>2025-04-15T04:32:06.404Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目回顾："><a href="#题目回顾：" class="headerlink" title="题目回顾："></a>题目回顾：</h2><p><strong>第一次作业</strong>：实现含有加，减，乘，幂次，数字，未知数的单层括号的表达式展开</p><p><strong>第二次作业</strong>：增加了三角函数，自定义函数与递推函数，允许多层括号嵌套</p><p><strong>第三次作业</strong>：增加了求导操作，增加了普通自定义函数</p><h2 id="程序整体架构"><a href="#程序整体架构" class="headerlink" title="程序整体架构"></a>程序整体架构</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="/2025/04/06/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B1%95%E5%BC%80/%E7%B1%BB%E5%9B%BE.png"></p><p>优点：使用两个接口，使架构清晰，方便统一管理，易于迭代。</p><p>缺点：其实写的时候感觉很舒服，没有感觉到有明显缺点（）</p><h3 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Class:</span><br><span class="line">MainClass:程序入口</span><br><span class="line">Solver:负责预处理输入数据，进行整个程序流程</span><br><span class="line">Lexer:词法分析器</span><br><span class="line">Parser:语法分析器</span><br><span class="line">Expr:表达式类</span><br><span class="line">Term:项类</span><br><span class="line">Number:数字因子类</span><br><span class="line">Pow:幂函数因子类</span><br><span class="line">TriFunc:三角函数因子类</span><br><span class="line">Function:函数因子类</span><br><span class="line">Derivation:导数因子类</span><br><span class="line">FunctionPattern:函数信息类，负责管理整个函数展开功能</span><br><span class="line">TriPair:自己写的Pair，存储一个三角函数内部的因子和幂次</span><br><span class="line">Poly:多项式类，用于储存数学表达式化简后的具体内容</span><br><span class="line">Mono:单项式类，Poly是Mono的组合</span><br><span class="line">Interface:</span><br><span class="line">Factor:因子接口，负责管理各个种类的因子</span><br><span class="line">包含:Expr,Number,Pow,TriFunc,Function,Derivation</span><br><span class="line">Branch:枝接口，负责管理表达式树上的非叶子节点——用于简化递归遍历表达式树的实现，增强可迭代性</span><br><span class="line">包含:Expr,TriFunc,Function,Derivation</span><br></pre></td></tr></table></figure><h3 id="性能度量分析"><a href="#性能度量分析" class="headerlink" title="性能度量分析"></a>性能度量分析</h3><p><img src="/2025/04/06/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B1%95%E5%BC%80/%E5%BA%A6%E9%87%8F1.png"></p><p><img src="/2025/04/06/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B1%95%E5%BC%80/%E5%BA%A6%E9%87%8F2.png"></p><table><thead><tr><th>Project</th><th>V(G)_avg</th><th>V(G)_tot</th></tr></thead><tbody><tr><td>Unit1</td><td>3.36</td><td>413</td></tr></tbody></table><h2 id="架构设计体验"><a href="#架构设计体验" class="headerlink" title="架构设计体验"></a>架构设计体验</h2><h4 id="第一次作业："><a href="#第一次作业：" class="headerlink" title="第一次作业："></a>第一次作业：</h4><p>第一次作业时，由于没有看OO的公众号文章，我没有选取用的比较广的 <code>Mono</code> 和 <code>Poly</code> 的架构，而是自己设计了基于<strong>继承</strong>的架构。</p><p>具体来说，在我们表达式的展开化简部分，我们要把各个数学单位的展开后的值存储起来，并为其加，乘，幂的运算专门写方法。在第一次作业通过一个 <code>HashMap&lt;BigInteger,BigInteger&gt; content</code> ，来存储系数指数的对应关系，已经足够使用。考虑到所有的数学单位都有这一个成员，并需要运算方法，我选择了使用继承结构，将各个数学单位归为数学表达式类 <code>Expression</code> 的子类中，在 <code>Expression</code> 中写入相关运算方法和成员。</p><p>第一次作业最终的架构整体流程则为，首先对输入进行<strong>预处理</strong>，去除空白字符，前缀零，对于一些连续的加减符号进行合并，然后利用 <code>parser</code> 对表达式进行<strong>递归下降</strong>解析，建立树状结构。接下来<strong>二次扫描</strong>，为每一个数学单位写 <code>simpilfy</code> 方法，扫描过程中自上向下递归进行<strong>遍历</strong>，每一个节点先调用儿子的 <code>simplify</code> 方法，接下来使用 <code>Expression</code> 的加，乘等方法直接对儿子进行运算，得到自己的 <code>content</code> ，最终得到结果。</p><h3 id="重构"><a href="#重构" class="headerlink" title="重构:"></a>重构:</h3><p>由于各个类的共性在于其拥有一个<strong>共同的成员</strong>，而我们设计的父类的运算方法也在于这些成员之间的运算方法。所以实际上<strong>将这一个共同的成员专门建类</strong>，并在这个类中设计运算方法更加合适。</p><p>在第一次作业迭代到第二次作业时，之前架构的缺陷使迭代难以进行，故我对第一次作业的代码进行了重构。重构的点主要在于<strong>删除了继承关系</strong>，而将 <code>HashMap&lt;BigInteger,BigInteger&gt; content</code> <strong>封装</strong>了起来，并将其分为了两层，一层是表示单项式的 <code>Poly</code> ，一层是表示单项式的 <code>Mono</code> 。</p><p><code>Poly</code> 由 <code>ArrayList&lt;Mono&gt;</code> 组成。<code>Mono</code> 内部有相应的加，乘，的方法，而 <code>Poly</code> 拥有加，乘，幂次和合并内部 <code>Mono</code> 的方法（即寻找是否内部由指数相同的 <code>Mono</code>  ，将他们合并为一项）。这样的架构社计更为合理与清晰。</p><h3 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h3><p>第二次作业引入了三角函数和函数，迭代难度很大，以下是对于这两个问题的解决策略。</p><h4 id="三角函数带来的计算问题"><a href="#三角函数带来的计算问题" class="headerlink" title="三角函数带来的计算问题"></a>三角函数带来的计算问题</h4><p>继续沿用上一次作业的 <code>Mono</code> 和 <code>Poly</code> 方法，由于本次作业不能再表述为 $\sum\limits_{i&#x3D;1}^{n}a_ix^b$ 的形式，可以这样来表述：<br>$$<br>Poly &#x3D; \sum\limits_{i-1}^nMono &#x3D; \sum\limits_{i&#x3D;1}^{n}a_ix^{b_i}(\prod_{j&#x3D;1}^{n_1}sin(\alpha_j)^{\beta_j})(\prod_{k&#x3D;1}^{n_2} cos(\gamma_k)^{\aleph _k})<br>$$<br>对于  $sin$ 和 $cos$ 有关的内容，我们可以用两个 <code>HashMap&lt;Factor, Integer&gt;</code> 来解决。</p><blockquote><p>注：由于这里的 HashMap 其实只是利用了他能存一对值的特性，而没有用到他的 Map 特性，我在后续迭代中自己写了 <code>TriPair</code> ，并使用了 <code>ArrayList</code> 替代 <code>HashMap</code>。</p></blockquote><p>通过重写 <code>Mono</code> 中加，乘，幂次的方法，就可以解决三角函数的引入带来的计算问题。而 <code>Poly</code> 中的方法不需要大改，因为其只是 <code>Mono</code> 方法的组合。</p><h4 id="函数部分"><a href="#函数部分" class="headerlink" title="函数部分"></a>函数部分</h4><h5 id="核心思路："><a href="#核心思路：" class="headerlink" title="核心思路："></a>核心思路：</h5><ul><li><p>建立<code>FunctionPattern</code>类对函数进行预处理</p></li><li><p>通过对<strong>幂函数</strong>的替换，实现当 $n&#x3D;0,1$ 时，函数因子对表达式因子的转换方法</p></li><li><p>通过递归调用函数转换方法来解决 $n$ 较大时的函数问题。</p></li></ul><h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><p>我们在预处理时，通过建立一个 <code>FunctionPattern</code> 类，来解析并记录$f_0$ ,$f_1$ 的<strong>内容</strong>，以及 $f_n$ 的<strong>构造方法</strong>。</p><p>细节来说，对于 $f_0$ 和 $f_1$ 的解析我们可以使用现成的 <code>parseExpr</code>，而 $f_n$ 的构造方法我们要记录两个用来乘的<strong>系数</strong>，利用 <code>parseFactor</code> 来解析两个&#x2F;四个参数因子，以及可能存在的，需要额外加上的表达式。即我们需要解析下面列出的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f&#123;n&#125;(x,y) = k1*f&#123;n-1&#125;(f1a1,f1a2) + k2*f&#123;n-2&#125;(f2a1,f2a2) + fnContent</span><br><span class="line">f&#123;0&#125;(x,y) = f0Content</span><br><span class="line">f&#123;1&#125;(x,y) = f1Content</span><br></pre></td></tr></table></figure><p>在 <code>FunctionPattern</code>类中，我们需要实现一个关键方法 <code>Expr functionToExpr(Integer functionNum, ArrayList&lt;Factor&gt; arguments) </code>，通过调用该方法，可以实现<strong>传入一个函数因子的序号以及其参数列表，返回一个处理完毕的表达式</strong>的功能。</p><p>关于其具体实现，可以分为以下两种情况：</p><ul><li><p>如果  <code>functionNumer</code> 为 <code>1</code> 或 <code>0</code> ，则对<code>f1Content</code>或 <code>f1Content</code> 做一个<strong>深拷贝，复制其所有的值，而不是复制其指针</strong>（如果不这么做的话，每次调用都会破坏 <code>f0Content</code> 或 <code>f1Content</code>）</p><p><strong>遍历</strong>深拷贝后的表达式，如果在某一层级，发现他的一个儿子是一个<strong>幂函数</strong>类型的因子，则对这个幂函数的变量名 对应的参数做一个<strong>深拷贝</strong>，将这个 <code>Factor</code> 类型的对象在外面套一层 <code>Expr </code>，在套上的这层 <code>Expr</code> 上面，加上被替换的幂函数的因子。</p><p>这里的替换一定要使用 <code>ArrayList</code> 的 <strong><code>set(i,Factor)</code></strong> 这样的方法，可以防止被重复替换。</p></li><li><p>如果 <code>functionNumber</code> 大于 <code>1</code>，则首先调用本方法，解析出 <code>f&#123;n-1&#125;(arguments)</code> 和 <code>f&#123;n-2&#125;(arguments)</code> 对应的两个表达式，然后已知 <code>k1</code>，<code>k2</code> ，<code>fnContent</code>，构造出对应的表达式并返回即可。</p><p><strong>注意：</strong> <code>fnContent</code> 也要进行<strong>深拷贝</strong>并进行<strong>遍历替换</strong></p></li></ul><p>关于这个类的使用，我在 <code>Solver</code> 中提前解析了该类，然后把他作为了 <code>simplify</code> 方法的工具参数，递归往下传，如果看到了函数因子就使用这个工具。</p><p>这样子差不多就能解决函数问题了，关于对于幂函数的遍历替换和深拷贝部分，则需要在<code>Expr</code>,<code>Term</code>等等诸多类中完成其方法，才能实现完整的深拷贝和遍历替换。</p><p>对于函数中引入的多变量xy有关的处理，我们注意到，我们只需在解析时知道是多变量，而不需要实际利用多变量进行任何的运算操作。</p><p>可以直接在幂函数类中增加一个 <code>String varName</code> 成员，记录其名称，在处理函数时对多变量进行处理。而在计算时，我们把幂函数仍作为 $x^n$ 来看没有任何影响。这样子多变量就轻松解决了。</p><h3 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h3><p>第三次作业迭代增加了更多自定义函数，以及求导操作，难度较小。</p><h4 id="更多自定义函数的引入"><a href="#更多自定义函数的引入" class="headerlink" title="更多自定义函数的引入"></a>更多自定义函数的引入</h4><p>由于<strong>函数名</strong>不再局限于 <code>f</code> ，我们需要在函数因子中增加成员 String functionName，同时扩充parseFunction和预处理函数的内容和 funcToExpr 的参数列表（增加 String functionName），以让我们的程序能够解析更多的函数。</p><p>关于函数的处理我们只需改变 FunctionPattern 即可，增加对于其他函数的<strong>预处理</strong>，同时扩充 FunctionPattern 内部的方法，使<strong>funcToExpr</strong>能够解析其他的函数即可。</p><h4 id="求导操作的引入"><a href="#求导操作的引入" class="headerlink" title="求导操作的引入"></a>求导操作的引入</h4><p>对于求导操作，只需增加<strong>导数因子</strong>及相应的解析方式。在Mono中增加<strong>Mono的求导方法</strong>，并利用 Mono 的求导方法拼出 Poly 的求导方法。Mono 和 Poly 其他内容我们无需改动。</p><h3 id="假设新的迭代情景"><a href="#假设新的迭代情景" class="headerlink" title="假设新的迭代情景"></a>假设新的迭代情景</h3><p>我们假设引入了虚数单位 <code>i</code> ，关于我的程序事实上不需要过多的改动。</p><h4 id="增加虚数因子"><a href="#增加虚数因子" class="headerlink" title="增加虚数因子"></a>增加虚数因子</h4><p>需要增加虚数因子有关的词法解析和语法解析，并增加虚数因子类。以及关于虚数因子的输出逻辑。</p><h4 id="增加虚数有关运算"><a href="#增加虚数有关运算" class="headerlink" title="增加虚数有关运算"></a>增加虚数有关运算</h4><p>在Mono中增加一个关于虚数flag的成员，同时增加 Mono<strong>乘法</strong>关于虚数的相关逻辑，和对于加法<strong>合并</strong>判断时的判断逻辑。</p><h2 id="程序-bug-分析"><a href="#程序-bug-分析" class="headerlink" title="程序 bug 分析"></a>程序 bug 分析</h2><p>本人的程序在第一单元中被互测<strong>TLE</strong> 攻击成功过一次。追数据开放后才发现， hacker 使用嵌套极深（约20层）的 sin 嵌套成功让我程序 TLE 卡炸了。</p><p>bug 的主要原因在于，本人的 Mono 项内部存储了 sin 与  cos 内部的 Factor ，而本人在<strong>深拷贝</strong>的过程中，对于 Factor 的  Poly 进行了深拷贝，而 Poly 又对 Mono 进行深拷贝，Mono 又对其所有属性进行了深拷贝。这个行为逻辑上没有问题，但是 Mono 的深拷贝同样拷贝了它的 Factor ，接下来会不断<strong>嵌套</strong>下去，导致每一次拷贝的时间复杂度都是基于嵌套层数的指数级函数，故会被深层次嵌套进行 TLE 攻击。但是事实上 Mono 对于其因子的深拷贝时不必要的，因为深拷贝的主要目的是防止对象被其他管理者进行预料之外的修改，但是 Mono 不会去修改 Factor 的任何内容，故 在 bug 修复时只需删掉 Mono 对于 Factor 的深拷贝调用即可。</p><p>事实上这个 bug 较为隐蔽。由于缺乏经验，在深拷贝时我严格按照深拷贝时的相关逻辑以防出错，但是正是因为这个，导致逻辑上正确，却在性能上吃亏。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th></th><th>行复杂度</th><th>圈复杂度</th></tr></thead><tbody><tr><td>出现了bug的方法</td><td>1</td><td>0</td></tr><tr><td>未出现bug的方法</td><td>1</td><td>0</td></tr></tbody></table><p>本方法在修改前后的复杂度完全一致且均很低，从这里无法得到结论。</p><h3 id="发现别人-bug-采取的策略"><a href="#发现别人-bug-采取的策略" class="headerlink" title="发现别人 bug 采取的策略"></a>发现别人 bug 采取的策略</h3><p>首先最有效但是效率较低的方法当然是<strong>评测机轰炸</strong>了！通过数据生成器，按照文法逻辑递归生成较为全面的数据。数据生成器要保证数据要有一定的复杂度，能够随机出来大多数情况，同时又要<strong>控制数据的规模</strong>不能过大，以防评测机无法评测（时间超时）。</p><p>其次是<strong>手动构造极端样例</strong>，例如多层 sin 嵌套攻击一些 TLE 的 bug ，以及 (x)^8^ 嵌套 这种 bug，这种数据一般无法用评测机roll出来，手动构造较为合适。</p><p>我 hack 时并无阅读别人代码，通过阅读代码的方式攻击<strong>效率过低</strong>，且很难有收益，不如评测机（）。</p><h3 id="优化分析"><a href="#优化分析" class="headerlink" title="优化分析"></a>优化分析</h3><p>每增加一行代码有可能引入潜在的bug，因此我只进行最易进行的优化，将 $asin(\delta)^2+bcos(\delta)^2$ 优化为了 $(a-b)sin(\delta)^2+b$ ，并消掉其中的含零项。这个优化可以通过为 Poly 重写 equals 方法，来对三角函数内部因子进行比较，并在 Poly 进行加法时尝试优化。</p><p>同时，对于<strong>同类项的合并</strong>优化也较为简单，同样是重写 equals 方法，在相加时合并，这里不多赘述。</p><p>本人的优化仍然能保证程序的简洁性。关键在于将优化所使用的代码封装起来，并将功能逐级拆分。例如，在进行优化时有一个前提条件是两个 Mono 都为 $asin&#x2F;cos(x)^2$ 的形式，我在 Mono 中设计了 potential 方法，表示这一个 Mono 具有这样的特性（即拥有继续优化的潜力），这样就增加了优化代码的可读性，优化的功能调用时也只用增加一行函数即可。</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><h3 id="对于架构的体会"><a href="#对于架构的体会" class="headerlink" title="对于架构的体会"></a>对于架构的体会</h3><p>第一次作业是我完全理解了架构设计对于面向对象项目的重要性，一个好的架构能够增强代码的可读性和可迭代性，同时使自己编程使有一个清晰的思路，清楚的明白自己在做什么，要做什么。</p><p>一个好的架构，应当将功能封装独立起来，满足高内聚低耦合的特征。同时要能够提取共性特征，建立适当的接口，以方便统一管理，降低代码的复杂度，减少重复代码，方便迭代。</p><h3 id="对于测试的体会"><a href="#对于测试的体会" class="headerlink" title="对于测试的体会"></a>对于测试的体会</h3><p>一个<strong>自动化的，可复用</strong>的自动测试工具在项目的开发中至关重要。在优化性能，增量开发，修复bug的过程中，很有可能会对之前代码的正确性造成影响。在代码迭代的时候，一个好的评测系统可以帮助自己快速定位bug。</p><p>本次作业我直接使用互测用于攻击别人的<strong>评测机</strong>来进行<strong>高强度自测</strong>，在自测后我的代码没有任何逻辑上的错误，只有性能上的缺陷。</p><h3 id="对于评测机以及大模型使用的一些小心得"><a href="#对于评测机以及大模型使用的一些小心得" class="headerlink" title="对于评测机以及大模型使用的一些小心得"></a>对于评测机以及大模型使用的一些小心得</h3><p>本人的评测机主要分为三部分，数据生成器，对拍器，以及整合脚本。数据生成器将批量的数据生成到一个文件夹下，对拍器读取这个文件夹的数据，将标程和待测jar文件的输出数据也放到这个文件夹中。</p><p>评测机的数据生成器和对拍器的分离我认为是一个非常重要的设计，通过分离的设计，可以选择使用数据生成器的数据还是使用文件夹中本来就有的数据。</p><p>同时，评测机的对拍器（spj）部分逻辑较为简单，我们可以把这些任务丢给大模型来做，自己完成逻辑复杂的数据生成器部分。这样能够提升我们的很多工作效率。</p><p>使用大模型时，最重要的是能够给出明确清晰的提示词，我将我制作spj的提示词放在下面，可供参考。</p><p><img src="/2025/04/06/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B1%95%E5%BC%80/prompt.png"></p><p>当然，我们使用时要<strong>严格按照课程的制度</strong>，在禁止使用的部分（如作业本体）不要用大模型。</p><h2 id="未来方向"><a href="#未来方向" class="headerlink" title="未来方向"></a>未来方向</h2><ul><li>希望课程组优化课程网站<strong>排版</strong>，尤其是形式化表述的部分，不要用不加任何修饰的普通文字堆成一坨，观感很差。</li><li>希望<strong>难度提升更加平滑</strong>，本次作业第一单元hw1到hw2的难度提升很大，而hw2到hw3的难度提升较小，我身边不乏写hw2用了十小时以上，写hw3只用了三个小时的同学。可以将求导和三角函数操作放在hw2，自定义函数的两个部分整合一起放在hw3。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目回顾：&quot;&gt;&lt;a href=&quot;#题目回顾：&quot; class=&quot;headerlink&quot; title=&quot;题目回顾：&quot;&gt;&lt;/a&gt;题目回顾：&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;第一次作业&lt;/strong&gt;：实现含有加，减，乘，幂次，数字，未知数的单层括号的表达式展开&lt;/p&gt;
</summary>
      
    
    
    
    
    <category term="面向对象设计与构造" scheme="http://s7777777h.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
</feed>
