<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>s7777777h&#39;s Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2025-04-06T08:41:18.571Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>s7777777h</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>OO第一单元总结 - 表达式展开</title>
    <link href="http://example.com/2025/04/06/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B1%95%E5%BC%80/"/>
    <id>http://example.com/2025/04/06/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B1%95%E5%BC%80/</id>
    <published>2025-04-06T08:33:24.000Z</published>
    <updated>2025-04-06T08:41:18.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目回顾："><a href="#题目回顾：" class="headerlink" title="题目回顾："></a>题目回顾：</h2><p><strong>第一次作业</strong>：实现含有加，减，乘，幂次，数字，未知数的单层括号的表达式展开</p><p><strong>第二次作业</strong>：增加了三角函数，自定义函数与递推函数，允许多层括号嵌套</p><p><strong>第三次作业</strong>：增加了求导操作，增加了普通自定义函数</p><h2 id="程序整体架构"><a href="#程序整体架构" class="headerlink" title="程序整体架构"></a>程序整体架构</h2><h3 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h3><p><img src="/2025/04/06/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B1%95%E5%BC%80/%E7%B1%BB%E5%9B%BE.png"></p><p>优点：使用两个接口，使架构清晰，方便统一管理，易于迭代。</p><p>缺点：其实写的时候感觉很舒服，没有感觉到有明显缺点（）</p><h3 id="架构介绍"><a href="#架构介绍" class="headerlink" title="架构介绍"></a>架构介绍</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Class:</span><br><span class="line">MainClass:程序入口</span><br><span class="line">Solver:负责预处理输入数据，进行整个程序流程</span><br><span class="line">Lexer:词法分析器</span><br><span class="line">Parser:语法分析器</span><br><span class="line">Expr:表达式类</span><br><span class="line">Term:项类</span><br><span class="line">Number:数字因子类</span><br><span class="line">Pow:幂函数因子类</span><br><span class="line">TriFunc:三角函数因子类</span><br><span class="line">Function:函数因子类</span><br><span class="line">Derivation:导数因子类</span><br><span class="line">FunctionPattern:函数信息类，负责管理整个函数展开功能</span><br><span class="line">TriPair:自己写的Pair，存储一个三角函数内部的因子和幂次</span><br><span class="line">Poly:多项式类，用于储存数学表达式化简后的具体内容</span><br><span class="line">Mono:单项式类，Poly是Mono的组合</span><br><span class="line">Interface:</span><br><span class="line">Factor:因子接口，负责管理各个种类的因子</span><br><span class="line">包含:Expr,Number,Pow,TriFunc,Function,Derivation</span><br><span class="line">Branch:枝接口，负责管理表达式树上的非叶子节点——用于简化递归遍历表达式树的实现，增强可迭代性</span><br><span class="line">包含:Expr,TriFunc,Function,Derivation</span><br></pre></td></tr></table></figure><h3 id="性能度量分析"><a href="#性能度量分析" class="headerlink" title="性能度量分析"></a>性能度量分析</h3><p><img src="/2025/04/06/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B1%95%E5%BC%80/%E5%BA%A6%E9%87%8F1.png"></p><p><img src="/2025/04/06/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B1%95%E5%BC%80/%E5%BA%A6%E9%87%8F2.png"></p><table><thead><tr><th>Project</th><th>V(G)_avg</th><th>V(G)_tot</th></tr></thead><tbody><tr><td>Unit1</td><td>3.36</td><td>413</td></tr></tbody></table><h2 id="架构设计体验"><a href="#架构设计体验" class="headerlink" title="架构设计体验"></a>架构设计体验</h2><h4 id="第一次作业："><a href="#第一次作业：" class="headerlink" title="第一次作业："></a>第一次作业：</h4><p>第一次作业时，由于没有看OO的公众号文章，我没有选取用的比较广的 <code>Mono</code> 和 <code>Poly</code> 的架构，而是自己设计了基于<strong>继承</strong>的架构。</p><p>具体来说，在我们表达式的展开化简部分，我们要把各个数学单位的展开后的值存储起来，并为其加，乘，幂的运算专门写方法。在第一次作业通过一个 <code>HashMap&lt;BigInteger,BigInteger&gt; content</code> ，来存储系数指数的对应关系，已经足够使用。考虑到所有的数学单位都有这一个成员，并需要运算方法，我选择了使用继承结构，将各个数学单位归为数学表达式类 <code>Expression</code> 的子类中，在 <code>Expression</code> 中写入相关运算方法和成员。</p><p>第一次作业最终的架构整体流程则为，首先对输入进行<strong>预处理</strong>，去除空白字符，前缀零，对于一些连续的加减符号进行合并，然后利用 <code>parser</code> 对表达式进行<strong>递归下降</strong>解析，建立树状结构。接下来<strong>二次扫描</strong>，为每一个数学单位写 <code>simpilfy</code> 方法，扫描过程中自上向下递归进行<strong>遍历</strong>，每一个节点先调用儿子的 <code>simplify</code> 方法，接下来使用 <code>Expression</code> 的加，乘等方法直接对儿子进行运算，得到自己的 <code>content</code> ，最终得到结果。</p><h3 id="重构"><a href="#重构" class="headerlink" title="重构:"></a>重构:</h3><p>由于各个类的共性在于其拥有一个<strong>共同的成员</strong>，而我们设计的父类的运算方法也在于这些成员之间的运算方法。所以实际上<strong>将这一个共同的成员专门建类</strong>，并在这个类中设计运算方法更加合适。</p><p>在第一次作业迭代到第二次作业时，之前架构的缺陷使迭代难以进行，故我对第一次作业的代码进行了重构。重构的点主要在于<strong>删除了继承关系</strong>，而将 <code>HashMap&lt;BigInteger,BigInteger&gt; content</code> <strong>封装</strong>了起来，并将其分为了两层，一层是表示单项式的 <code>Poly</code> ，一层是表示单项式的 <code>Mono</code> 。</p><p><code>Poly</code> 由 <code>ArrayList&lt;Mono&gt;</code> 组成。<code>Mono</code> 内部有相应的加，乘，的方法，而 <code>Poly</code> 拥有加，乘，幂次和合并内部 <code>Mono</code> 的方法（即寻找是否内部由指数相同的 <code>Mono</code>  ，将他们合并为一项）。这样的架构社计更为合理与清晰。</p><h3 id="第二次作业"><a href="#第二次作业" class="headerlink" title="第二次作业"></a>第二次作业</h3><p>第二次作业引入了三角函数和函数，迭代难度很大，以下是对于这两个问题的解决策略。</p><h4 id="三角函数带来的计算问题"><a href="#三角函数带来的计算问题" class="headerlink" title="三角函数带来的计算问题"></a>三角函数带来的计算问题</h4><p>继续沿用上一次作业的 <code>Mono</code> 和 <code>Poly</code> 方法，由于本次作业不能再表述为 $\sum\limits_{i&#x3D;1}^{n}a_ix^b$ 的形式，可以这样来表述：<br>$$<br>Poly &#x3D; \sum\limits_{i-1}^nMono &#x3D; \sum\limits_{i&#x3D;1}^{n}a_ix^{b_i}(\prod_{j&#x3D;1}^{n_1}sin(\alpha_j)^{\beta_j})(\prod_{k&#x3D;1}^{n_2} cos(\gamma_k)^{\aleph _k})<br>$$<br>对于  $sin$ 和 $cos$ 有关的内容，我们可以用两个 <code>HashMap&lt;Factor, Integer&gt;</code> 来解决。</p><blockquote><p>注：由于这里的 HashMap 其实只是利用了他能存一对值的特性，而没有用到他的 Map 特性，我在后续迭代中自己写了 <code>TriPair</code> ，并使用了 <code>ArrayList</code> 替代 <code>HashMap</code>。</p></blockquote><p>通过重写 <code>Mono</code> 中加，乘，幂次的方法，就可以解决三角函数的引入带来的计算问题。而 <code>Poly</code> 中的方法不需要大改，因为其只是 <code>Mono</code> 方法的组合。</p><h4 id="函数部分"><a href="#函数部分" class="headerlink" title="函数部分"></a>函数部分</h4><h5 id="核心思路："><a href="#核心思路：" class="headerlink" title="核心思路："></a>核心思路：</h5><ul><li><p>建立<code>FunctionPattern</code>类对函数进行预处理</p></li><li><p>通过对<strong>幂函数</strong>的替换，实现当 $n&#x3D;0,1$ 时，函数因子对表达式因子的转换方法</p></li><li><p>通过递归调用函数转换方法来解决 $n$ 较大时的函数问题。</p></li></ul><h5 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h5><p>我们在预处理时，通过建立一个 <code>FunctionPattern</code> 类，来解析并记录$f_0$ ,$f_1$ 的<strong>内容</strong>，以及 $f_n$ 的<strong>构造方法</strong>。</p><p>细节来说，对于 $f_0$ 和 $f_1$ 的解析我们可以使用现成的 <code>parseExpr</code>，而 $f_n$ 的构造方法我们要记录两个用来乘的<strong>系数</strong>，利用 <code>parseFactor</code> 来解析两个&#x2F;四个参数因子，以及可能存在的，需要额外加上的表达式。即我们需要解析下面列出的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f&#123;n&#125;(x,y) = k1*f&#123;n-1&#125;(f1a1,f1a2) + k2*f&#123;n-2&#125;(f2a1,f2a2) + fnContent</span><br><span class="line">f&#123;0&#125;(x,y) = f0Content</span><br><span class="line">f&#123;1&#125;(x,y) = f1Content</span><br></pre></td></tr></table></figure><p>在 <code>FunctionPattern</code>类中，我们需要实现一个关键方法 <code>Expr functionToExpr(Integer functionNum, ArrayList&lt;Factor&gt; arguments) </code>，通过调用该方法，可以实现<strong>传入一个函数因子的序号以及其参数列表，返回一个处理完毕的表达式</strong>的功能。</p><p>关于其具体实现，可以分为以下两种情况：</p><ul><li><p>如果  <code>functionNumer</code> 为 <code>1</code> 或 <code>0</code> ，则对<code>f1Content</code>或 <code>f1Content</code> 做一个<strong>深拷贝，复制其所有的值，而不是复制其指针</strong>（如果不这么做的话，每次调用都会破坏 <code>f0Content</code> 或 <code>f1Content</code>）</p><p><strong>遍历</strong>深拷贝后的表达式，如果在某一层级，发现他的一个儿子是一个<strong>幂函数</strong>类型的因子，则对这个幂函数的变量名 对应的参数做一个<strong>深拷贝</strong>，将这个 <code>Factor</code> 类型的对象在外面套一层 <code>Expr </code>，在套上的这层 <code>Expr</code> 上面，加上被替换的幂函数的因子。</p><p>这里的替换一定要使用 <code>ArrayList</code> 的 <strong><code>set(i,Factor)</code></strong> 这样的方法，可以防止被重复替换。</p></li><li><p>如果 <code>functionNumber</code> 大于 <code>1</code>，则首先调用本方法，解析出 <code>f&#123;n-1&#125;(arguments)</code> 和 <code>f&#123;n-2&#125;(arguments)</code> 对应的两个表达式，然后已知 <code>k1</code>，<code>k2</code> ，<code>fnContent</code>，构造出对应的表达式并返回即可。</p><p><strong>注意：</strong> <code>fnContent</code> 也要进行<strong>深拷贝</strong>并进行<strong>遍历替换</strong></p></li></ul><p>关于这个类的使用，我在 <code>Solver</code> 中提前解析了该类，然后把他作为了 <code>simplify</code> 方法的工具参数，递归往下传，如果看到了函数因子就使用这个工具。</p><p>这样子差不多就能解决函数问题了，关于对于幂函数的遍历替换和深拷贝部分，则需要在<code>Expr</code>,<code>Term</code>等等诸多类中完成其方法，才能实现完整的深拷贝和遍历替换。</p><p>对于函数中引入的多变量xy有关的处理，我们注意到，我们只需在解析时知道是多变量，而不需要实际利用多变量进行任何的运算操作。</p><p>可以直接在幂函数类中增加一个 <code>String varName</code> 成员，记录其名称，在处理函数时对多变量进行处理。而在计算时，我们把幂函数仍作为 $x^n$ 来看没有任何影响。这样子多变量就轻松解决了。</p><h3 id="第三次作业"><a href="#第三次作业" class="headerlink" title="第三次作业"></a>第三次作业</h3><p>第三次作业迭代增加了更多自定义函数，以及求导操作，难度较小。</p><h4 id="更多自定义函数的引入"><a href="#更多自定义函数的引入" class="headerlink" title="更多自定义函数的引入"></a>更多自定义函数的引入</h4><p>由于<strong>函数名</strong>不再局限于 <code>f</code> ，我们需要在函数因子中增加成员 String functionName，同时扩充parseFunction和预处理函数的内容和 funcToExpr 的参数列表（增加 String functionName），以让我们的程序能够解析更多的函数。</p><p>关于函数的处理我们只需改变 FunctionPattern 即可，增加对于其他函数的<strong>预处理</strong>，同时扩充 FunctionPattern 内部的方法，使<strong>funcToExpr</strong>能够解析其他的函数即可。</p><h4 id="求导操作的引入"><a href="#求导操作的引入" class="headerlink" title="求导操作的引入"></a>求导操作的引入</h4><p>对于求导操作，只需增加<strong>导数因子</strong>及相应的解析方式。在Mono中增加<strong>Mono的求导方法</strong>，并利用 Mono 的求导方法拼出 Poly 的求导方法。Mono 和 Poly 其他内容我们无需改动。</p><h3 id="假设新的迭代情景"><a href="#假设新的迭代情景" class="headerlink" title="假设新的迭代情景"></a>假设新的迭代情景</h3><p>我们假设引入了虚数单位 <code>i</code> ，关于我的程序事实上不需要过多的改动。</p><h4 id="增加虚数因子"><a href="#增加虚数因子" class="headerlink" title="增加虚数因子"></a>增加虚数因子</h4><p>需要增加虚数因子有关的词法解析和语法解析，并增加虚数因子类。以及关于虚数因子的输出逻辑。</p><h4 id="增加虚数有关运算"><a href="#增加虚数有关运算" class="headerlink" title="增加虚数有关运算"></a>增加虚数有关运算</h4><p>在Mono中增加一个关于虚数flag的成员，同时增加 Mono<strong>乘法</strong>关于虚数的相关逻辑，和对于加法<strong>合并</strong>判断时的判断逻辑。</p><h2 id="程序-bug-分析"><a href="#程序-bug-分析" class="headerlink" title="程序 bug 分析"></a>程序 bug 分析</h2><p>本人的程序在第一单元中被互测<strong>TLE</strong> 攻击成功过一次。追数据开放后才发现， hacker 使用嵌套极深（约20层）的 sin 嵌套成功让我程序 TLE 卡炸了。</p><p>bug 的主要原因在于，本人的 Mono 项内部存储了 sin 与  cos 内部的 Factor ，而本人在<strong>深拷贝</strong>的过程中，对于 Factor 的  Poly 进行了深拷贝，而 Poly 又对 Mono 进行深拷贝，Mono 又对其所有属性进行了深拷贝。这个行为逻辑上没有问题，但是 Mono 的深拷贝同样拷贝了它的 Factor ，接下来会不断<strong>嵌套</strong>下去，导致每一次拷贝的时间复杂度都是基于嵌套层数的指数级函数，故会被深层次嵌套进行 TLE 攻击。但是事实上 Mono 对于其因子的深拷贝时不必要的，因为深拷贝的主要目的是防止对象被其他管理者进行预料之外的修改，但是 Mono 不会去修改 Factor 的任何内容，故 在 bug 修复时只需删掉 Mono 对于 Factor 的深拷贝调用即可。</p><p>事实上这个 bug 较为隐蔽。由于缺乏经验，在深拷贝时我严格按照深拷贝时的相关逻辑以防出错，但是正是因为这个，导致逻辑上正确，却在性能上吃亏。</p><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table><thead><tr><th></th><th>行复杂度</th><th>圈复杂度</th></tr></thead><tbody><tr><td>出现了bug的方法</td><td>1</td><td>0</td></tr><tr><td>未出现bug的方法</td><td>1</td><td>0</td></tr></tbody></table><p>本方法在修改前后的复杂度完全一致且均很低，从这里无法得到结论。</p><h3 id="发现别人-bug-采取的策略"><a href="#发现别人-bug-采取的策略" class="headerlink" title="发现别人 bug 采取的策略"></a>发现别人 bug 采取的策略</h3><p>首先最有效但是效率较低的方法当然是<strong>评测机轰炸</strong>了！通过数据生成器，按照文法逻辑递归生成较为全面的数据。数据生成器要保证数据要有一定的复杂度，能够随机出来大多数情况，同时又要<strong>控制数据的规模</strong>不能过大，以防评测机无法评测（时间超时）。</p><p>其次是<strong>手动构造极端样例</strong>，例如多层 sin 嵌套攻击一些 TLE 的 bug ，以及 (x)^8^ 嵌套 这种 bug，这种数据一般无法用评测机roll出来，手动构造较为合适。</p><p>我 hack 时并无阅读别人代码，通过阅读代码的方式攻击<strong>效率过低</strong>，且很难有收益，不如评测机（）。</p><h3 id="优化分析"><a href="#优化分析" class="headerlink" title="优化分析"></a>优化分析</h3><p>每增加一行代码有可能引入潜在的bug，因此我只进行最易进行的优化，将 $asin(\delta)^2+bcos(\delta)^2$ 优化为了 $(a-b)sin(\delta)^2+b$ ，并消掉其中的含零项。这个优化可以通过为 Poly 重写 equals 方法，来对三角函数内部因子进行比较，并在 Poly 进行加法时尝试优化。</p><p>同时，对于<strong>同类项的合并</strong>优化也较为简单，同样是重写 equals 方法，在相加时合并，这里不多赘述。</p><p>本人的优化仍然能保证程序的简洁性。关键在于将优化所使用的代码封装起来，并将功能逐级拆分。例如，在进行优化时有一个前提条件是两个 Mono 都为 $asin&#x2F;cos(x)^2$ 的形式，我在 Mono 中设计了 potential 方法，表示这一个 Mono 具有这样的特性（即拥有继续优化的潜力），这样就增加了优化代码的可读性，优化的功能调用时也只用增加一行函数即可。</p><h2 id="心得体会"><a href="#心得体会" class="headerlink" title="心得体会"></a>心得体会</h2><h3 id="对于架构的体会"><a href="#对于架构的体会" class="headerlink" title="对于架构的体会"></a>对于架构的体会</h3><p>第一次作业是我完全理解了架构设计对于面向对象项目的重要性，一个好的架构能够增强代码的可读性和可迭代性，同时使自己编程使有一个清晰的思路，清楚的明白自己在做什么，要做什么。</p><p>一个好的架构，应当将功能封装独立起来，满足高内聚低耦合的特征。同时要能够提取共性特征，建立适当的接口，以方便统一管理，降低代码的复杂度，减少重复代码，方便迭代。</p><h3 id="对于测试的体会"><a href="#对于测试的体会" class="headerlink" title="对于测试的体会"></a>对于测试的体会</h3><p>一个<strong>自动化的，可复用</strong>的自动测试工具在项目的开发中至关重要。在优化性能，增量开发，修复bug的过程中，很有可能会对之前代码的正确性造成影响。在代码迭代的时候，一个好的评测系统可以帮助自己快速定位bug。</p><p>本次作业我直接使用互测用于攻击别人的<strong>评测机</strong>来进行<strong>高强度自测</strong>，在自测后我的代码没有任何逻辑上的错误，只有性能上的缺陷。</p><h3 id="对于评测机以及大模型使用的一些小心得"><a href="#对于评测机以及大模型使用的一些小心得" class="headerlink" title="对于评测机以及大模型使用的一些小心得"></a>对于评测机以及大模型使用的一些小心得</h3><p>本人的评测机主要分为三部分，数据生成器，对拍器，以及整合脚本。数据生成器将批量的数据生成到一个文件夹下，对拍器读取这个文件夹的数据，将标程和待测jar文件的输出数据也放到这个文件夹中。</p><p>评测机的数据生成器和对拍器的分离我认为是一个非常重要的设计，通过分离的设计，可以选择使用数据生成器的数据还是使用文件夹中本来就有的数据。</p><p>同时，评测机的对拍器（spj）部分逻辑较为简单，我们可以把这些任务丢给大模型来做，自己完成逻辑复杂的数据生成器部分。这样能够提升我们的很多工作效率。</p><p>使用大模型时，最重要的是能够给出明确清晰的提示词，我将我制作spj的提示词放在下面，可供参考。</p><p><img src="/2025/04/06/OO%E7%AC%AC%E4%B8%80%E5%8D%95%E5%85%83%E6%80%BB%E7%BB%93-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%B1%95%E5%BC%80/prompt.png"></p><p>当然，我们使用时要<strong>严格按照课程的制度</strong>，在禁止使用的部分（如作业本体）不要用大模型。</p><h2 id="未来方向"><a href="#未来方向" class="headerlink" title="未来方向"></a>未来方向</h2><ul><li>希望课程组优化课程网站<strong>排版</strong>，尤其是形式化表述的部分，不要用不加任何修饰的普通文字堆成一坨，观感很差。</li><li>希望<strong>难度提升更加平滑</strong>，本次作业第一单元hw1到hw2的难度提升很大，而hw2到hw3的难度提升较小，我身边不乏写hw2用了十小时以上，写hw3只用了三个小时的同学。可以将求导和三角函数操作放在hw2，自定义函数的两个部分整合一起放在hw3。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目回顾：&quot;&gt;&lt;a href=&quot;#题目回顾：&quot; class=&quot;headerlink&quot; title=&quot;题目回顾：&quot;&gt;&lt;/a&gt;题目回顾：&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;第一次作业&lt;/strong&gt;：实现含有加，减，乘，幂次，数字，未知数的单层括号的表达式展开&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
